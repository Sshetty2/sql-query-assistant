"""Handle errors from query execution by having LLM analyze and suggest fixes."""

import os
from dotenv import load_dotenv
from textwrap import dedent
from pydantic import BaseModel, Field
from langchain_core.messages import AIMessage
from utils.llm_factory import get_structured_llm
from utils.logger import get_logger, log_execution_time

load_dotenv()
logger = get_logger()


class ErrorCorrection(BaseModel):
    """Pydantic model for error correction output."""

    reasoning: str = Field(
        description="Explanation of what caused the error and how it was corrected"
    )
    sql_query: str = Field(description="The corrected SQL query")


def handle_tool_error(state) -> dict:
    """Handle errors from query execution by getting LLM to analyze and suggest fixes."""
    error_message = state["messages"][-1].content
    original_query = state["query"]
    retry_count = state.get("retry_count", 0)

    logger.info(
        "Starting error correction",
        extra={
            "retry_count": retry_count,
            "error": error_message,
            "original_query": original_query,
        },
    )

    # Use filtered schema if available, otherwise use full schema
    schema = state.get("filtered_schema") or state["schema"]
    error_history = state["error_history"][:-1]

    prompt = dedent(
        f"""
        # SQL Query Error Correction

        ## We are trying to correct a SQL query that was generated by an an LLM model and raised an error when it was executed.

        ## Erroring Query

        ```sql
        {original_query}
        ```

        ## Latest Error

        ```
        {error_message}
        ```

        ## Previous Error History

        {chr(10).join(['- ' + err for err in error_history]) if error_history else 'No previous errors'}

        ## Database Schema

        ```json
        {schema}
        ```

        ---

        ## IMPORTANT: Error Correction Strategy

        **First Priority - MAINTAIN THE ORIGINAL INTENT OF THE QUERY:**

        **Second Priority - Simplify the Query:**
        - Double-check that all referenced columns actually exist in their respective tables
        - Verify that all referenced tables exist in the schema
        - Ensure column names match exactly (case-sensitive on some databases)
        - Check that table aliases are used correctly if present

        **Third Priority - Verify Schema Accuracy:**
        - Consider simplifying the query to address the error within reason
        - Remove offending columns or joins that are causing the error
        - Simplify WHERE clause conditions or time filters if they're causing problems
        - Sometimes a simpler version of the query is better than a complex failing one

        **Additional Considerations:**
        - Review the error history to avoid repeating the same mistake
        - If time filters are problematic, consider removing them
        - Ensure proper SQL Server T-SQL syntax is used
        - Check for syntax errors in complex expressions

        ---

        ## Instructions

        Analyze the error and provide a corrected SQL query.

        Return a JSON object with:
        - `reasoning`: Explanation of what caused the error and how it was corrected
        - `sql_query`: The corrected SQL query
         """  # noqa: E501
    )

    # Get structured LLM (handles method="json_schema" for Ollama automatically)
    structured_llm = get_structured_llm(
        ErrorCorrection, model_name=os.getenv("AI_MODEL"), temperature=0.3
    )

    with log_execution_time(logger, "llm_error_correction_invocation"):
        response = structured_llm.invoke(prompt)

    logger.info(
        "Error correction completed",
        extra={
            "corrected_query_length": len(response.sql_query),
            "corrected_query": response.sql_query,
        },
    )

    return {
        **state,
        "messages": [AIMessage(content="Generated corrected SQL query")],
        "query": response.sql_query,
        "retry_count": state["retry_count"] + 1,
        "corrected_queries": state["corrected_queries"] + [original_query],
        "error_reasoning": state.get("error_reasoning", []) + [response.reasoning],
        "last_step": "handle_tool_error",
    }
